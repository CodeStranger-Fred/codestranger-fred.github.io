---
layout: post
title: Spring Cloud Netflix Deployment
---

<h3>1. Spring Cloud Netflix</h3><p><strong>Spring Cloud Netflix</strong> is a core subproject of <strong>Spring Cloud</strong> and is a wrapper around a series of open-source products from Netflix. It provides automatic integration for Spring Boot applications, allowing you to quickly use these tools in Spring Cloud applications with just a few annotations.</p><p>The main modules it provides are:</p><ul><li><strong>Service Discovery and Registration (Eureka)</strong></li><li><strong>Client-side Load Balancing (Ribbon)</strong></li><li><strong>Circuit Breaker (Hystrix)</strong></li><li><strong>API Gateway (Zuul)</strong></li></ul><h3>2. Service Registration and Discovery (Eureka)</h3><h4>2.1 Implementation of Service Registration and Discovery</h4><p>To set up <strong>Eureka</strong> for service registration and discovery, follow these steps:</p><ol><li><strong>Create a Eureka Server (Registry) Project</strong> and include the required dependency.</li></ol><p><strong>pom.xml file</strong>:</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>2. <strong>Enable Eureka Server</strong>: Add @EnableEurekaServer annotation to your main class.</p><pre>@SpringBootApplication<br>@EnableEurekaServer<br>public class EurekaServerApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    }<br>}</pre><p><strong>3. Configure </strong><strong>application.properties file</strong>:</p><pre># Server port (default Eureka port: 8761)<br>server.port=8761<br><br># Application name<br>spring.application.name=spring-cloud-server<br><br># Eureka configuration<br># Whether to register with Eureka (set to false as it&#39;s a server)<br>eureka.client.register-with-eureka=false<br><br># Whether to fetch registry information from Eureka<br>eureka.client.fetch-registry=false<br><br># Eureka server URL (remember the &quot;/eureka/&quot; part is required)<br>eureka.client.serviceUrl.defaultZone=http://localhost:${server.port}/eureka/</pre><p>4. After starting the service, visit http://localhost:8761/ to view the Eureka dashboard.</p><p><strong>Note</strong>: The registry might enter <strong>Protection Mode</strong> when the service starts, requiring some time to validate the services.</p><h4>2.2 Registering a Service Provider (Eureka Client)</h4><p>To register a service as a <strong>Eureka Client</strong> (service provider), follow these steps:</p><ol><li><strong>Create a Service Provider</strong> and include the following dependency:</li></ol><p><strong>pom.xml file</strong>:</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>2. <strong>Enable Eureka Client</strong>: Add @EnableEurekaClient annotation to the main class.</p><pre>@SpringBootApplication<br>@EnableEurekaClient<br>public class EurekaClientApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.run(EurekaClientApplication.class, args);<br>    }<br>}</pre><p>3. <strong>Configure </strong><strong>application.properties file</strong>:</p><pre># Service port<br>server.port=8762<br><br># Application name<br>spring.application.name=spring-cloud-provider<br><br># Eureka server URL<br>eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</pre><p>4. After starting the service, visit http://localhost:8761/ to check if the service provider is successfully registered under the <strong>&quot;Instances currently registered with Eureka&quot;</strong> section.</p><h4>2.3 Registering a Service Consumer</h4><p>To register a <strong>service consumer</strong>, follow the same process as the service provider. Just create a new project with the same client dependency, and adjust the service name and port in the configuration file.</p><p><strong>application.properties file</strong>:</p><pre>server.port=8888<br>spring.application.name=spring-cloud-consumer<br>eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/</pre><p>Once the consumer service is started, you should see it registered in the Eureka dashboard as well.</p><h4>2.4 Important Notes</h4><ul><li><strong>Tomcat Dependency</strong>: Since spring-cloud-starter-netflix-eureka-client does not include <strong>Tomcat</strong> by default, if you&#39;re building a web application, you need to manually add the <strong>Spring Boot Web Starter</strong>.</li></ul><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><h3>3. Comparing Eureka and Zookeeper</h3><p>In distributed systems, service registry and discovery can be implemented using different tools, and two common ones are <strong>Eureka</strong> and <strong>Zookeeper</strong>. They have different philosophies when it comes to consistency and availability.</p><h4>3.1 CAP Theorem in Distributed Systems</h4><ul><li><strong>Consistency ©</strong>: All nodes always have the same data.</li><li><strong>Availability (A)</strong>: Every request gets a response, either success or failure.</li><li><strong>Partition Tolerance (P)</strong>: The system should continue operating even if network partitioning occurs.</li></ul><p>In practice, partition tolerance (P) is a must in distributed systems, so a trade-off between <strong>A</strong> (Availability) and <strong>C</strong> (Consistency) must be made.</p><h4>3.2 Zookeeper Guarantees CP (Consistency and Partition Tolerance)</h4><p>Zookeeper is a <strong>CP</strong> system (Consistency and Partition Tolerance). It ensures that at any given moment, requests to Zookeeper are consistent, i.e., all nodes see the same data. However, in cases of network partitioning, it may sacrifice <strong>availability</strong>, meaning that some requests might be dropped to ensure consistency.</p><ul><li>Zookeeper is ideal for systems that require strong consistency and can tolerate some unavailability during network issues.</li></ul><h4>3.3 Eureka Guarantees AP (Availability and Partition Tolerance)</h4><p>Eureka is designed to guarantee <strong>AP</strong> (Availability and Partition Tolerance). It prioritizes availability over strict consistency. For example, if Eureka loses a large number of heartbeats (service failures), it enters <strong>Self-Preservation Mode</strong>, where it retains stale data to avoid downtime. In this mode, Eureka can continue registering new services and holding onto outdated information.</p><ul><li>Eureka is ideal for systems where <strong>availability</strong> is more important than absolute consistency. It is more tolerant of <strong>stale data</strong> but will continue operating even when some services are temporarily unavailable.</li></ul><p>Eureka’s philosophy is that <strong>keeping bad data is better than losing data</strong>. It will retain all service registration information (both live and dead) until the system recovers.</p><h4>3.4 Choosing Between Eureka and Zookeeper</h4><p>The choice between <strong>Eureka</strong> and <strong>Zookeeper</strong> depends on your system’s requirements. There is no one-size-fits-all architecture, and the “best” registry tool is the one that fits the business needs.</p><ul><li><strong>Eureka</strong> is best suited for applications that prioritize <strong>high availability</strong> and can tolerate some level of <strong>inconsistent data</strong> during partitions.</li><li><strong>Zookeeper</strong> is better for systems that require <strong>strong consistency</strong> and can accept reduced availability during network partitions.</li></ul><h3>Conclusion</h3><ul><li><strong>Eureka</strong> prioritizes <strong>availability</strong> over consistency, making it more suitable for distributed systems where you cannot afford service downtime.</li><li><strong>Zookeeper</strong> prioritizes <strong>consistency</strong> over availability, making it better for systems that need strong consistency guarantees even at the expense of availability during partitions.</li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=aae06e835e46" width="1" height="1" alt="">
