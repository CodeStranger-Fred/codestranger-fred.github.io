---
layout: post
title: Integrating Hibernate Validation in Spring Boot for Advanced Parameter Validation
  — Class-level…
tag:
- java
- hibernate
- spring-boot
---

<h3><strong>Integrating Hibernate Validation in Spring Boot for Advanced Parameter Validation — Class-level Validation</strong></h3><p>In Spring Boot applications, parameter validation is crucial for ensuring that incoming data adheres to the expected formats, lengths, and business rules. The built-in Hibernate Validator, integrated with Spring Boot, allows for powerful and flexible validation strategies. In this blog post, we’ll explore how to configure and use Hibernate Validator with Spring Boot, including validation on both class properties and method parameters, custom error messages, and global exception handling.</p><h3>Table of Contents:</h3><ol><li><strong>Class-level Validation</strong></li><li><strong>Method-level Validation</strong></li><li><strong>Hibernate Validation Modes</strong></li><li><strong>Group Validation</strong></li><li><strong>Configuring Error Messages in Spring Boot</strong></li><li><strong>Global Exception Handling with @ControllerAdvice</strong></li><li><strong>Common Validation Annotations</strong></li></ol><h3>1. Class-level Validation (Field Validation)</h3><p>In everyday development, it’s common to have fields that need validation, such as ensuring that an email is correctly formatted, or a password adheres to certain rules. Without proper validation, you end up with messy and repetitive code across your application.</p><p>Spring Boot comes with hibernate-validator out of the box when you include the spring-boot-starter-web dependency, so no additional dependencies are needed. We can use annotations like @NotBlank, @Max, and @Min for field-level validation.</p><h4>Example:</h4><p>Let’s say we have a User class that needs validation on the username and password fields.</p><pre>import javax.validation.constraints.*;<br>public class User {<br>@NotBlank(message = &quot;{user.name.notBlank}&quot;, groups = {GroupA.class})<br> private String username; // Username<br>@Max(value = 999999, message = &quot;Password exceeds the maximum value&quot;)<br> @Min(value = 100000, message = &quot;Password must be at least 6 digits&quot;)<br> @NotNull(message = &quot;Password cannot be null&quot;)<br> private String password; // Password<br>}</pre><h4>Controller with Validation:</h4><p>In the controller, we use @Valid on the method parameters and BindingResult to capture validation errors:</p><pre>import org.springframework.validation.BindingResult;<br>import org.springframework.web.bind.annotation.*;<br><br>@RestController<br>public class UserController {<br><br>    @PostMapping(&quot;/createuser&quot;)<br>    public String createUser(@Valid User user, BindingResult bindingResult) {<br>        if (bindingResult.hasErrors()) {<br>            return bindingResult.getFieldError().getDefaultMessage();<br>        } else {<br>            // Call the service to create the user<br>            return &quot;User created successfully&quot;;<br>        }<br>    }<br>}</pre><p>In this example, if there are any validation errors (e.g., empty fields or invalid passwords), they will be captured and returned in the response.</p><p>In next post, we will talk about method-level validation.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=25f90454ee2b" width="1" height="1" alt="">
